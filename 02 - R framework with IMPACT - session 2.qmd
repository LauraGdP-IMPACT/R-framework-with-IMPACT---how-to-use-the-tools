---
title: "02 - R framework with IMPACT - session 2"
author: "Yann Say"
date: last-modified

format:
  html:
    toc: true
    css: config/css/styles.css
    df-print: kable
    embed-resources: true
---


```{r}
#| warning: false
library(cleaningtools)
library(dplyr)

my_raw_dataset <- cleaningtools::cleaningtools_raw_data
my_kobo_survey <- cleaningtools::cleaningtools_survey
my_kobo_choice <- cleaningtools::cleaningtools_choices
```

# Recap

```{r}
#| output: false
more_logs <- my_raw_dataset %>% 
  check_duplicate(uuid_column = "X_uuid") %>% 
  check_soft_duplicates(uuid_column = "X_uuid", kobo_survey = my_kobo_survey, sm_separator = ".") %>%
  check_outliers(uuid_column = "X_uuid") %>%
  check_value(uuid_column = "X_uuid") 
more_logs$checked_dataset <- more_logs$checked_dataset %>% 
  add_duration(uuid_column = "X_uuid", start_column = "X.U.FEFF.start", end_column = "end")
more_logs <- more_logs %>% 
  check_duration(column_to_check = "duration", uuid_column = "X_uuid")
other_columns_to_check <- my_kobo_survey %>% 
  filter(type == "text") %>% 
  filter(name %in% names(my_raw_dataset)) %>%
  pull(name) 

more_logs <- more_logs %>% 
  check_others(uuid_column = "X_uuid", columns_to_check = other_columns_to_check) 
logical_check_list <- readxl::read_excel("inputs/01 - example - check_list.xlsx")
more_logs <- more_logs %>% 
  check_logical_with_list(uuid_column = "X_uuid",
                          list_of_check = logical_check_list,
                          check_id_column = "check_id",
                          check_to_perform_column = "check_to_perform",
                          columns_to_clean_column = "columns_to_clean",
                          description_column = "description")

```


# Creating a cleaning log

::: {.callout-tip appearance="minimal"}
### create\_\*

**create_**\* functions will create, transform something, e.g. creating a cleaning log with the checks to be filled, create analysis results table, create an output.

Outputs from **create_**\* functions outputs can be in different shape, format, etc. 

**create_**\* function is catch-all.
:::

## create_combined_log

`create_combined_log` will combined all the logs from a list into one. It will also add 2 columns that will be used for the cleaning.

```{r}
names(more_logs)
my_combined_log <- create_combined_log(more_logs)

typeof(my_combined_log)
names(my_combined_log)

my_combined_log$cleaning_log %>% 
  head()
```

The cleaning log contains all the columns from all the logs from `more_logs` with in addition:

-   check_binding is filled for all rows.
-   change_type (empty)
-   new_value (empty)

## add_info_to_cleaning_log

If more information from the dataset should be added, the function `add_info_to_cleaning_log` can help.

::: {.callout-tip appearance="minimal"}
### add\_\*

**add_**\* functions will add a variable (column) to the dataset. For example, to add the duration of a survey, to add the food consumption score category, etc.

**add_**\* function takes a dataset as input and returns the dataset + the new indicator (and any intermediate steps used for the calculation). 

For example, to check the duration of a survey, there is only the start and end, but not the duration column.
:::

```{r}
my_combined_log <- my_combined_log %>% 
  add_info_to_cleaning_log(dataset_uuid_column = "X_uuid", 
                           information_to_add = "enumerator_num")

my_combined_log$cleaning_log %>% 
  head()
```

## create_xlsx_cleaning_log

```{r}
#| output: false
create_xlsx_cleaning_log(my_combined_log,
                         sm_dropdown_type = "logical",
                         output_path =  "outputs/01 - example - cleaning-log-no-kobo.xlsx")
```

`create_xlsx_cleaning_log` will write an excel file with:

-   checked_dataset tab: the checked dataset, with additional columns if any.
-   cleaning_log tab: the combined log with the **change_type** column with a data validation rules.
-   readme tab: change_type values definition.

There are 4 actions possible:

-   change_response: Change the response to new.value
-   blank_response: Remove and NA the response
-   remove_survey: Delete the survey
-   no_action: No action to take.

This log will have to be filled in with actions to take and new value if needed.

```{r}
#| output: false
create_xlsx_cleaning_log(my_combined_log,
                         kobo_survey = my_kobo_survey,
                         kobo_choices = my_kobo_choice,
                         use_dropdown = T,
                         sm_dropdown_type = "logical",
                         output_path =  "outputs/02 - example - cleaning-log-with-kobo.xlsx")
```

If the KOBO information are provided and the **use_dropdown** argument is set to TRUE, **new_value** will have a data validation rule based on the KOBO options.

::: callout-note
Select multiple dummy columns (TRUE/FALSE or 1/0) are flagged and used later for the cleaning, not the parent column.
:::


# Creating a clean dataset

::: callout-important
The cleaning has to be filled before moving forward. The above steps are to create the cleaning log, not to **fill** it or **clean** the dataset. Filling the cleaning log is not an automatic step for this process. The decision to change a value has to be recorded.
:::

::: {.callout-tip appearance="minimal"}
### review\_\*

**review_**\* functions will review an object by comparing it to standards or another object and flags differences, e.g. reviewing the cleaning by comparing the raw dataset, the clean dataset and the cleaning log, analysis comparing it with another analysis. 

-   if the cleaning has been filled correctly
-   the cleaning has been done correctly
-   comparing indicators
-   comparing analysis
-   etc.
:::

## review_cleaning_log

`review_cleaning_log` will review the **filled** cleaning log.

```{r}
my_filled_log <- readxl::read_excel("inputs/02 - example - cleaning-log-with-kobo - filled.xlsx", sheet = 2)

check_log_results <- review_cleaning_log(raw_dataset = my_raw_dataset,
                                        raw_data_uuid_column = "X_uuid",
                                        cleaning_log = my_filled_log, 
                                        cleaning_log_uuid_column = "uuid",
                                        cleaning_log_question_column = "question",
                                        cleaning_log_new_value_column = "new_value",
                                        cleaning_log_change_type_column = "change_type",
                                        change_response_value = "change_response")
check_log_results
```

## create_clean_data

To create the clean dataset, `create_clean_data` will use the raw dataset and the filled cleaning log.

```{r}
my_clean_data <- create_clean_data(raw_dataset = my_raw_dataset,
                                   raw_data_uuid_column = "X_uuid",
                                   cleaning_log = my_filled_log, 
                                   cleaning_log_uuid_column = "uuid",
                                   cleaning_log_question_column = "question",
                                   cleaning_log_new_value_column = "new_value",
                                   cleaning_log_change_type_column = "change_type")
```

## recreate_parent_column

In the cleaning log, some select multiple are changed, but only the dummy. The parent column should be recoded also.

```{r}
my_filled_log %>% 
  filter(question == "primary_livelihood.employment", 
         change_type == "change_response") %>% 
  select(uuid, question, old_value, new_value)
```

```{r}
my_clean_data %>% 
  filter(X_uuid %in% c("eb3b9935-fa0b-4d54-8058-3b629f1421ad", "eec1f630-15d5-475e-a344-32bba74b32ea", "f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb")) %>% 
  select(X_uuid,primary_livelihood, primary_livelihood.employment)
```

```{r}
#| output: false
my_clean_data2 <- recreate_parent_column(dataset = my_clean_data,
                                         uuid_column = "X_uuid",
                                         kobo_survey = my_kobo_survey,
                                         kobo_choices = my_kobo_choice,
                                         sm_separator = ".", 
                                         cleaning_log_to_append = my_filled_log)
```

```{r}
my_clean_data2$data_with_fix_concat %>% 
  filter(X_uuid %in% c("eb3b9935-fa0b-4d54-8058-3b629f1421ad", "eec1f630-15d5-475e-a344-32bba74b32ea", "f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb")) %>% 
  select(X_uuid,primary_livelihood, primary_livelihood.employment)
```

```{r}
my_clean_data2$cleaning_log %>% 
  filter(question == "primary_livelihood", 
         uuid %in% c("eb3b9935-fa0b-4d54-8058-3b629f1421ad", "eec1f630-15d5-475e-a344-32bba74b32ea", "f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb")) %>% 
  select(uuid, question, old_value, new_value)
```

## review_others

In the cleaning log, some opentext values are changed to blank. Some open text questions are linked some skip logic, i.e. *what is X? Other, please specify*. In some cases, values some values should be changed.

In the example below, the value for **water_supply_other_neighbourhoods_why** for the **uuid 019bc718-c06a-46b8-bba8-c84f6c6efbd5** was changed to NA.

```{r}
my_filled_log %>% 
  filter(question == "water_supply_other_neighbourhoods_why", 
         change_type == "blank_response")
```

The kobo show a skip logic based on **water_supply_other_neighbourhoods**.

```{r}
my_kobo_survey %>% 
  filter(name == "water_supply_other_neighbourhoods_why") %>% 
  select(type, name, relevant)
```

```{r}
my_clean_data %>% 
  filter(X_uuid == "019bc718-c06a-46b8-bba8-c84f6c6efbd5") %>% 
  select(water_supply_other_neighbourhoods, water_supply_other_neighbourhoods_why	)
```

Should the value of **water_supply_other_neighbourhoods** be changed? It depends on the question and skip logic but it important to flag those so a decision can be taken.

```{r}
review_other_log <- review_others(dataset = my_clean_data2$data_with_fix_concat,
                                  uuid_column = "X_uuid", 
                                  kobo_survey = my_kobo_survey, 
                                  columns_not_to_check = "consent_telephone_number")
```

## review_cleaning

```{r}
#| output: false
my_deletion_log <- my_clean_data2$cleaning_log %>% 
  filter(change_type == "remove_survey")

my_filled_log_no_deletion <- my_clean_data2$cleaning_log %>% 
  filter(change_type != "remove_survey") %>% 
  filter(!uuid %in% my_deletion_log$uuid)

review_of_cleaning <- review_cleaning(raw_dataset = my_raw_dataset,
                    raw_dataset_uuid_column = "X_uuid", 
                    clean_dataset = my_clean_data2$data_with_fix_concat,
                    clean_dataset_uuid_column = "X_uuid",
                    cleaning_log = my_filled_log_no_deletion, 
                    cleaning_log_uuid_column = "uuid",
                    cleaning_log_question_column = "question",
                    cleaning_log_new_value_column = "new_value",
                    cleaning_log_change_type_column = "change_type", 
                    cleaning_log_old_value_column = "old_value", 
                    deletion_log = my_deletion_log, 
                    deletion_log_uuid_column = "uuid"
                    )
```

# Exercises

- Export the cleaning log you have created previously.
```{r}
previous_exercise_log <- readRDS("inputs/03 - exercise - previous_log.RDS")
```


::: {.callout-note collapse="true" appearance="minimal"}
### Expand to get a hint.

Did you try the function `create_combined_log`
:::

::: {.callout-note collapse="true" appearance="minimal"}
### Expand to get a hint.

Did you try the function `create_xlsx_cleaning_log`
:::

::: {.callout-tip collapse="true" appearance="minimal"}
### Expand to get the answer

```{r}
#| output: false
previous_exercise_log %>% 
  create_combined_log() %>%
  create_xlsx_cleaning_log(output_path = "outputs/03 - correction - cleaning_log.xlsx", 
                           kobo_survey = my_kobo_survey,
                           kobo_choices = my_kobo_choice,
                           sm_dropdown_type = "logical",
                           use_dropdown = TRUE)
  
```
:::

- *(Optional) Fill-in the log.*

- Create the clean data from the raw dataset and the filled cleaning.

```{r}
exercise_filled_log <- readxl::read_excel("inputs/04 - exercise - cleaning_log - filled.xlsx", sheet = "cleaning_log")
```

::: {.callout-note collapse="true" appearance="minimal"}
### Expand to get a hint

Did you try the function `create_clean_data`
:::

::: {.callout-note collapse="true" appearance="minimal"}
### Expand to get a hint

Did you try the function `recreate_parent_column`
:::

::: {.callout-tip collapse="true" appearance="minimal"}
### Expand to get the answer

```{r}
#| output: false
exercise_clean_dataset <- create_clean_data(raw_dataset = my_raw_dataset,
                                            raw_data_uuid_column = "X_uuid",
                                            cleaning_log = exercise_filled_log, 
                                            cleaning_log_uuid_column = "uuid",
                                            cleaning_log_question_column = "question",
                                            cleaning_log_new_value_column = "new_value",
                                            cleaning_log_change_type_column = "change_type")


exercise_clean_dataset2 <- recreate_parent_column(exercise_clean_dataset,
                                                  uuid_column = "X_uuid", 
                                                  kobo_survey = my_kobo_survey,
                                                  kobo_choices = my_kobo_choice,
                                                  cleaning_log_to_append = exercise_filled_log)

  
```
:::

- Review the cleaning below, if there is someone else doing the exercise, you can try to review someone's cleaning.

```{r}
exercise3_clean_dataset <- readxl::read_excel("inputs/05 - exercise - clean dataset for review.xlsx")

exercise3_cleaning_log <- readxl::read_excel("inputs/05 - exercise - clean dataset for review.xlsx", sheet = 2)

```

::: {.callout-note collapse="true" appearance="minimal"}
### Expand to get a hint

Did you try the function `review_cleaning`
:::

::: {.callout-note collapse="true" appearance="minimal"}
### Expand to get a hint

Did you separate the cleaning log?
:::

::: {.callout-tip collapse="true" appearance="minimal"}
### Expand to get the answer

```{r}
#| output: false
exercise3_deletion_log <- exercise3_cleaning_log %>% 
  filter(change_type == "remove_survey")

exercise3_log_no_deletion <- exercise3_cleaning_log %>% 
  filter(change_type != "remove_survey") %>% 
  filter(!uuid %in% exercise3_deletion_log$uuid)

review_of_cleaning <- review_cleaning(raw_dataset = my_raw_dataset,
                                      raw_dataset_uuid_column = "X_uuid", 
                                      clean_dataset = exercise3_clean_dataset,
                                      clean_dataset_uuid_column = "X_uuid",
                                      cleaning_log = exercise3_log_no_deletion, 
                                      cleaning_log_uuid_column = "uuid",
                                      cleaning_log_question_column = "question",
                                      cleaning_log_new_value_column = "new_value",
                                      cleaning_log_change_type_column = "change_type", 
                                      cleaning_log_old_value_column = "old_value", 
                                      deletion_log = exercise3_deletion_log, 
                                      deletion_log_uuid_column = "uuid"
)
```

:::
