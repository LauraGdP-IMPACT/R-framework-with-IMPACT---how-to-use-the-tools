{
  "hash": "c3149e5c7f1d6148be5cedf4b1a2e910",
  "result": {
    "markdown": "---\ntitle: \"R cozy winter\"\nauthor: \"Yann Say\"\ndate: today\n\nformat:\n  html:\n    toc: true\n    css: css/styles.css\n    df-print: kable\n    embed-resources: true\n\n---\n\n# IMPACT R framework\n\n---\n\nThe IMPACT R framework has been developed to meet the requirements of the IMPACT research cycle. \n<br/><br/> \nThe ecosystem is a modular framework with two dimensions:\n\n-   a horizontal dimension that focuses on the outcome of a given step, and\n-   a vertical dimension that focuses on the content of a given step.\n\n---\n\nThe framework is built around:\n\n-   4 ~~packages~~ steps: cleaning, ~~indicators~~ composition, analysis, outputs\n-   4 verbs: check, add, create, review\n-   2 adjectives: pipeable, independent\n\nThese elements will help to improve cooperation and collaboration between different teams while \nallowing modularity to adapt to each context and assessment.\n\n---\n\n![](images/rframwork.png)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cleaningtools)\nlibrary(dplyr)\n\nmy_raw_dataset <- cleaningtools::cleaningtools_raw_data\nmy_kobo_survey <- cleaningtools::cleaningtools_survey\nmy_kobo_choice <- cleaningtools::cleaningtools_choices\n```\n:::\n\n# Checking a dataset\n\n::: {.callout-tip appearance=\"minimal\"}\n### check_*\n\nThe framework is built around 4 verbs: **add**, **check**, **create**, **review**. Most of the functions to check the cleaning will be around the verb **check**. A **check_*** function will flag values based on a specific check. It will return them in a log. A **check_*** will returns a list: the checked dataset, and the log. \n**check_*** functions are used only in the cleaning step.\n:::\n\n## check_outliers\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log1 <- my_raw_dataset %>% \n  check_outliers(uuid_column = \"X_uuid\")\n```\n:::\n\n\nIn this example, there are:\n\n* `checked_dataset`: the raw dataset (with extra variables if needed)\n* `potential_outliers`: a log of potential outliers\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(my_log1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nmy_log1 %>% \n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"checked_dataset\"    \"potential_outliers\"\n```\n:::\n:::\n\n\nThe log has at least 4 columns:\n\n* `uuid`: the unique identifier\n* `issue`: the issue being flagged\n* `question`: the name of the question\n* `old_value`: the value being flagged\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log1$potential_outliers %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |issue                         |question         | old_value|\n|:------------------------------------|:-----------------------------|:----------------|---------:|\n|b5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06 |outlier (normal distribution) |age_respondent_r |        86|\n|956b5ed0-5a62-41b7-aec3-af93fbc5b494 |outlier (normal distribution) |age_respondent_r |        84|\n|97ad6294-30c6-454e-a0b3-42126415b767 |outlier (log distribution)    |age_respondent_r |        18|\n|e005e719-57c4-44a3-ac2f-5d6d1ff68831 |outlier (log distribution)    |age_respondent_r |        18|\n|c9aaa542-118f-4e42-93de-fb0916572541 |outlier (normal distribution) |num_hh_member    |        19|\n|48e8896b-d1be-4600-8839-2d8b994ebcfb |outlier (normal distribution) |num_hh_member    |        19|\n\n</div>\n:::\n:::\n\n\n::: {.callout-note .column-margin}\nOutliers are defined as +/- 3 standard deviation from the mean. \n\nFor log outliers, log(x + 1) is used.\n:::\n\n## check_duplicate\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log2 <- my_raw_dataset %>% \n  check_duplicate(uuid_column = \"X_uuid\")\n\nmy_log2$duplicate_log %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid |old_value |question |issue |\n|:----|:---------|:--------|:-----|\n\n</div>\n:::\n:::\n\n\nThere is no duplicate. The log is empty.\n\n::: {.callout-tip appearance=\"minimal\"}\n### Pipe-able\n\nThe framework is built around 2 adjectives, **pipe-able** and **independent**. In the framework, functions of the same family should be pipe-able. In the following case, 2 **check_*** functions are piped.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log3 <- my_raw_dataset %>% \n  check_outliers(uuid_column = \"X_uuid\") %>% \n  check_duplicate(uuid_column = \"X_uuid\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(my_log3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"checked_dataset\"    \"potential_outliers\" \"duplicate_log\"     \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log3$potential_outliers %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |issue                         |question         | old_value|\n|:------------------------------------|:-----------------------------|:----------------|---------:|\n|b5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06 |outlier (normal distribution) |age_respondent_r |        86|\n|956b5ed0-5a62-41b7-aec3-af93fbc5b494 |outlier (normal distribution) |age_respondent_r |        84|\n|97ad6294-30c6-454e-a0b3-42126415b767 |outlier (log distribution)    |age_respondent_r |        18|\n|e005e719-57c4-44a3-ac2f-5d6d1ff68831 |outlier (log distribution)    |age_respondent_r |        18|\n|c9aaa542-118f-4e42-93de-fb0916572541 |outlier (normal distribution) |num_hh_member    |        19|\n|48e8896b-d1be-4600-8839-2d8b994ebcfb |outlier (normal distribution) |num_hh_member    |        19|\n\n</div>\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log3$duplicate_log %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid |old_value |question |issue |\n|:----|:---------|:--------|:-----|\n\n</div>\n:::\n:::\n\n## More checks\n\nThis an example of more checks that exist.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmore_logs <- my_raw_dataset %>% \n  check_duplicate(uuid_column = \"X_uuid\") %>% \n  check_soft_duplicates(uuid_column = \"X_uuid\", kobo_survey = my_kobo_survey, sm_separator = \".\") %>%\n  check_outliers(uuid_column = \"X_uuid\") %>%\n  check_value(uuid_column = \"X_uuid\") \n```\n:::\n\n\n::: {.callout-tip appearance=\"minimal\"}\n### add_* \n\n**add_*** functions will add a variable (column) to the dataset. For example, to check the duration of a survey, there is only the start and end, but not the duration column. \n:::\n\n## add_duration\n\n::: {.cell}\n\n```{.r .cell-code}\nmore_logs$checked_dataset <- more_logs$checked_dataset %>% \n  add_duration(uuid_column = \"X_uuid\", start_column = \"X.U.FEFF.start\", end_column = \"end\")\nmore_logs$checked_dataset[1:6, c(\"start_date\", \"start_time\", \"end_date\", \"end_time\", \"days_diff\", \"duration\")]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|start_date |start_time   |end_date   |end_time     |days_diff | duration|\n|:----------|:------------|:----------|:------------|:---------|--------:|\n|2021-07-05 |658.57 mins  |2021-07-05 |696.68 mins  |0 days    |    38.11|\n|2021-07-05 |608.90 mins  |2021-07-05 |641.92 mins  |0 days    |    33.02|\n|2021-07-05 |682.23 mins  |2021-07-05 |726.43 mins  |0 days    |    44.20|\n|2021-07-04 |1342.98 mins |2021-07-04 |1380.15 mins |0 days    |    37.17|\n|2021-07-04 |1391.62 mins |2021-07-05 |18.88 mins   |1 days    |    67.26|\n|2021-07-05 |617.38 mins  |2021-07-05 |756.52 mins  |0 days    |   139.14|\n\n</div>\n:::\n:::\n\n::: {.callout-warning .column-margin}\nThe duration is added to the `checked_dataset` in the list, not in the `my_raw_dataset` dataframe. The **check_*** functions are used in a pipe, so it needs the current dataset to be modified.\n:::\n\n::: {.callout-warning .column-margin}\nAt the moment, `add_duration` takes very specific format. It will change in the future to become more robust and using **lubridate**.\n:::\n\n`check_duration` can now be used with the previous checks.\n\n::: {.cell}\n\n```{.r .cell-code}\nmore_logs <- more_logs %>% \n  check_duration(column_to_check = \"duration\", uuid_column = \"X_uuid\")\n```\n:::\n\n\nAs much as possible, **check_*** functions take default argument or the functions will be able to guess some information, e.g. the `check_outliers` function guesses some numerical values. Some functions need more information.\n\n## other/text columns\n`check_other` needs the list of columns to be checked. It currently, it cannot detect the open text question. KOBO tool can be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nother_columns_to_check <- my_kobo_survey %>% \n  dplyr::filter(type == \"text\") %>% \n  dplyr::filter(name %in% names(my_raw_dataset)) %>%\n  dplyr::pull(name) \n\nmore_logs <- more_logs %>% \n  check_others(uuid_column = \"X_uuid\", columns_to_check = other_columns_to_check) \n```\n:::\n\n\n## check_logical\nIn other cases, the check is specific and should be tailored to the dataset, for example, `check_logical`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_logic <- my_raw_dataset %>% \n  check_logical(uuid_column = \"X_uuid\", \n                check_to_perform = \"primary_livelihood.employment == 1 & tot_expenses < 200000\",\n                description = \"primary_livelihood is employment but expenses less than 200 000\",\n                columns_to_clean = c(\"primary_livelihood\", \"tot_expenses\"))\n\nexample_logic$logical_xx %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |question           |old_value  |issue                                                           |check_id   |check_binding                                       |\n|:------------------------------------|:------------------|:----------|:---------------------------------------------------------------|:----------|:---------------------------------------------------|\n|f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |primary_livelihood |employment |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |\n|f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |tot_expenses       |125000     |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |\n|e9f8b44c-c507-45a1-8d76-66d886437b8f |primary_livelihood |employment |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ e9f8b44c-c507-45a1-8d76-66d886437b8f |\n|e9f8b44c-c507-45a1-8d76-66d886437b8f |tot_expenses       |175000     |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ e9f8b44c-c507-45a1-8d76-66d886437b8f |\n|994a60b8-e640-425c-9774-160651d7af04 |primary_livelihood |employment |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ 994a60b8-e640-425c-9774-160651d7af04 |\n|994a60b8-e640-425c-9774-160651d7af04 |tot_expenses       |175000     |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ 994a60b8-e640-425c-9774-160651d7af04 |\n\n</div>\n:::\n:::\n\nThe log returns :\n\n* uuid\n* question: for all variables in **columns_to_clean**\n* old value: for all variables in **columns_to_clean**\n* issue\n* check_id: logical check identifier\n* check_binding: the combination of the check_id and the uuid. \n\nOne check can be flagged in several rows, in the example above, for each uuid, the primary_livelihood and tot_expenses are flagged.\n\nFormat for the **test_to_perform** should take the format based on *tidyverse*. That format is as if a new indicator is create with a `mutate`. That new indicator should be a logical (i.e. TRUE or FALSE) with TRUE being the value to flag. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_raw_dataset %>% \n  dplyr::mutate(xxx =  primary_livelihood == \"employment\" & tot_expenses < 1000000) %>% \n  dplyr::select(X_uuid, xxx, primary_livelihood, tot_expenses) %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|X_uuid                               |xxx   |primary_livelihood | tot_expenses|\n|:------------------------------------|:-----|:------------------|------------:|\n|dcf2753a-6ea2-40f5-b493-3527931ef96c |FALSE |loans support      |       250000|\n|8790ce5c-1c35-41a2-b3c0-538f937d5397 |TRUE  |employment         |       750000|\n|bb818e04-9c40-408e-919f-6b40ff1fdbb3 |FALSE |other              |       250000|\n|28b90cbb-2cf0-41c5-9ee1-1c719c0d4c02 |TRUE  |employment         |       600000|\n|7f2a0c6a-529b-481f-963f-a96dca2ec034 |TRUE  |employment         |       500000|\n|b4f92064-12ea-4970-b0f5-fd309de1dda3 |FALSE |retirement_fund    |       650000|\n\n</div>\n:::\n:::\n\n\nThe checked dataset will be return with one extra column, i.e. the logical variable with the name of the **check_id**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_logic$checked_dataset[1:6,tail(names(example_logic$checked_dataset))]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|X_submission_time   |X_notes |X_status          |X_submitted_by | X_index|logical_xx |\n|:-------------------|:-------|:-----------------|:--------------|-------:|:----------|\n|2021-07-05T09:34:15 |[]      |submitted_via_web |reach_irq      |       1|FALSE      |\n|2021-07-05T09:34:09 |[]      |submitted_via_web |reach_irq      |       2|FALSE      |\n|2021-07-05T09:34:33 |[]      |submitted_via_web |reach_irq      |       3|FALSE      |\n|2021-07-05T09:32:58 |[]      |submitted_via_web |reach_irq      |       4|FALSE      |\n|2021-07-05T09:32:59 |[]      |submitted_via_web |reach_irq      |       5|FALSE      |\n|2021-07-05T09:37:33 |[]      |submitted_via_web |reach_irq      |       6|FALSE      |\n\n</div>\n:::\n:::\n\n\n**check_to_perform** is written as a character, between quotes and using with regular expression, e.g. escaping the quotes in **\"employment\"**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_logic2 <- my_raw_dataset %>% \n  check_logical(uuid_column = \"X_uuid\", \n                check_to_perform = \"primary_livelihood == \\\"employment\\\" & tot_expenses < 1000000\",\n                description = \"primary_livelihood is rented but expenses less than 1 000 000\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in check_logical(., uuid_column = \"X_uuid\", check_to_perform\n= \"primary_livelihood == \\\"employment\\\" & tot_expenses < 1000000\", :\ncolumns_to_clean not shared, results may not be accurate\n```\n:::\n\n```{.r .cell-code}\nexample_logic2$logical_xx %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |question           |old_value  |issue                                                         |check_id   |check_binding                                       |\n|:------------------------------------|:------------------|:----------|:-------------------------------------------------------------|:----------|:---------------------------------------------------|\n|8790ce5c-1c35-41a2-b3c0-538f937d5397 |primary_livelihood |employment |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 8790ce5c-1c35-41a2-b3c0-538f937d5397 |\n|8790ce5c-1c35-41a2-b3c0-538f937d5397 |tot_expenses       |750000     |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 8790ce5c-1c35-41a2-b3c0-538f937d5397 |\n|28b90cbb-2cf0-41c5-9ee1-1c719c0d4c02 |primary_livelihood |employment |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 28b90cbb-2cf0-41c5-9ee1-1c719c0d4c02 |\n|28b90cbb-2cf0-41c5-9ee1-1c719c0d4c02 |tot_expenses       |600000     |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 28b90cbb-2cf0-41c5-9ee1-1c719c0d4c02 |\n|7f2a0c6a-529b-481f-963f-a96dca2ec034 |primary_livelihood |employment |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 7f2a0c6a-529b-481f-963f-a96dca2ec034 |\n|7f2a0c6a-529b-481f-963f-a96dca2ec034 |tot_expenses       |500000     |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 7f2a0c6a-529b-481f-963f-a96dca2ec034 |\n\n</div>\n:::\n:::\n\n\n::: {.callout-note .column-margin}\nIf you don't include **columns_to_clean** the `check_logical` function will try to guess the variables. Not guarantee it will read or pick the correct names.\n:::\n\nThis inherits from reading a checklist in an Excel format. In Excel, there is no quote.\n\n![](images/excelchecklist.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical_check_list <- readxl::read_excel(\"inputs/check_list.xlsx\")\nlogical_check_list\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|check_id |description                                                    |check_to_perform                                                             |columns_to_clean                                     |\n|:--------|:--------------------------------------------------------------|:----------------------------------------------------------------------------|:----------------------------------------------------|\n|check_1  |primary_livelihood is employment but expenses less than 200000 |primary_livelihood.employment == 1 & tot_expenses < 200000                   |primary_livelihood.employment,          \ntot_expenses |\n|check_2  |acces water and tank emptied                                   |access_water_enough == \"totally_insufficient\" & tank_emptied == \"about_half\" |access_water_enough, tank_emptied                    |\n\n</div>\n:::\n:::\n\nThis list can then be used with `check_logical_with_list`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmore_logs <- more_logs %>% \n  check_logical_with_list(uuid_column = \"X_uuid\",\n                          list_of_check = logical_check_list,\n                          check_id_column = \"check_id\",\n                          check_to_perform_column = \"check_to_perform\",\n                          columns_to_clean_column = \"columns_to_clean\",\n                          description_column = \"description\")\n```\n:::\n\n\n# Creating a cleaning log\n\n::: {.callout-tip appearance=\"minimal\"}\n### create_*\n\n**create_*** functions will create, transform something, for example, creating a cleaning log to be filled from the checks that were performed above. **create_*** outputs can be in different shape, format, etc. **create_*** function is catch-all. \n:::\n\n## create_combined_log\n\n`create_combined_log` will combined all the logs from a list into one. It will also add 2 columsn that will be used for the cleaning.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(more_logs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"checked_dataset\"    \"duplicate_log\"      \"soft_duplicate_log\"\n[4] \"potential_outliers\" \"flaged_value\"       \"duration_log\"      \n[7] \"other_log\"          \"logical_all\"       \n```\n:::\n\n```{.r .cell-code}\nmy_combined_log <- create_combined_log(more_logs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of element to combine- checked_dataset, duplicate_log, soft_duplicate_log, potential_outliers, flaged_value, duration_log, other_log, logical_all\n```\n:::\n\n```{.r .cell-code}\ntypeof(my_combined_log)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nnames(my_combined_log)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"checked_dataset\" \"cleaning_log\"   \n```\n:::\n\n```{.r .cell-code}\nmy_combined_log$cleaning_log %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |old_value |question         |issue                         |check_id |check_binding                                             |change_type |new_value |\n|:------------------------------------|:---------|:----------------|:-----------------------------|:--------|:---------------------------------------------------------|:-----------|:---------|\n|b5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06 |86        |age_respondent_r |outlier (normal distribution) |NA       |age_respondent_r ~/~ b5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06 |NA          |NA        |\n|956b5ed0-5a62-41b7-aec3-af93fbc5b494 |84        |age_respondent_r |outlier (normal distribution) |NA       |age_respondent_r ~/~ 956b5ed0-5a62-41b7-aec3-af93fbc5b494 |NA          |NA        |\n|97ad6294-30c6-454e-a0b3-42126415b767 |18        |age_respondent_r |outlier (log distribution)    |NA       |age_respondent_r ~/~ 97ad6294-30c6-454e-a0b3-42126415b767 |NA          |NA        |\n|e005e719-57c4-44a3-ac2f-5d6d1ff68831 |18        |age_respondent_r |outlier (log distribution)    |NA       |age_respondent_r ~/~ e005e719-57c4-44a3-ac2f-5d6d1ff68831 |NA          |NA        |\n|c9aaa542-118f-4e42-93de-fb0916572541 |19        |num_hh_member    |outlier (normal distribution) |NA       |num_hh_member ~/~ c9aaa542-118f-4e42-93de-fb0916572541    |NA          |NA        |\n|48e8896b-d1be-4600-8839-2d8b994ebcfb |19        |num_hh_member    |outlier (normal distribution) |NA       |num_hh_member ~/~ 48e8896b-d1be-4600-8839-2d8b994ebcfb    |NA          |NA        |\n\n</div>\n:::\n:::\n\nThe cleaning log contains all the columns from all the logs from `more_logs` with in addition:\n\n* check_binding is filled for all rows.\n* change_type (empty)\n* new_value (empty)\n\n## add_info_to_cleaning_log\n\nIf more information from the dataset should be added, the function `add_info_to_cleaning_log` can help.\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_combined_log <- my_combined_log %>% \n  add_info_to_cleaning_log(dataset_uuid_column = \"X_uuid\", \n                           information_to_add = \"enumerator_num\")\n\nmy_combined_log$cleaning_log %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |old_value                                                                        |question                              |issue                                           |check_id |check_binding                                                                  |change_type |new_value | enumerator_num|\n|:------------------------------------|:--------------------------------------------------------------------------------|:-------------------------------------|:-----------------------------------------------|:--------|:------------------------------------------------------------------------------|:-----------|:---------|--------------:|\n|019bc718-c06a-46b8-bba8-c84f6c6efbd5 |لا اعلم                                                                          |water_supply_other_neighbourhoods_why |recode other                                    |NA       |water_supply_other_neighbourhoods_why ~/~ 019bc718-c06a-46b8-bba8-c84f6c6efbd5 |NA          |NA        |             12|\n|019bc718-c06a-46b8-bba8-c84f6c6efbd5 |لا ارى جدوى من ذلك                                                               |prefer_not_engage_other               |recode other                                    |NA       |prefer_not_engage_other ~/~ 019bc718-c06a-46b8-bba8-c84f6c6efbd5               |NA          |NA        |             12|\n|019bc718-c06a-46b8-bba8-c84f6c6efbd5 |السلطات ليست مهتمة بالخدمات                                                      |trust_water_office_why_not            |recode other                                    |NA       |trust_water_office_why_not ~/~ 019bc718-c06a-46b8-bba8-c84f6c6efbd5            |NA          |NA        |             12|\n|019bc718-c06a-46b8-bba8-c84f6c6efbd5 |247.20                                                                           |duration                              |Duration is lower or higher than the thresholds |NA       |duration ~/~ 019bc718-c06a-46b8-bba8-c84f6c6efbd5                              |NA          |NA        |             12|\n|03183d24-0275-43fe-8976-d076f29de590 |عدم توفير خدمه المياه  في المنطقه وضعف في تزويد خدمه وعدد ساعات اقل تجهيز للبيوت |water_supply_other_neighbourhoods_why |recode other                                    |NA       |water_supply_other_neighbourhoods_why ~/~ 03183d24-0275-43fe-8976-d076f29de590 |NA          |NA        |              2|\n|03183d24-0275-43fe-8976-d076f29de590 |10                                                                               |pay_water_charges_amount              |outlier (log distribution)                      |NA       |pay_water_charges_amount ~/~ 03183d24-0275-43fe-8976-d076f29de590              |NA          |NA        |              2|\n\n</div>\n:::\n:::\n\n\n## create_xlsx_cleaning_log\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_xlsx_cleaning_log(my_combined_log,\n                         sm_dropdown_type = \"logical\",\n                         output_path =  \"outputs/cleaning-log-no-kobo.xlsx\")\n```\n:::\n\n\n`create_xlsx_cleaning_log` will write an excel file with:\n\n* checked_dataset tab: the checked dataset, with additional columns if any.\n* cleaning_log tab: the combined log with the **change_type** column with a data validation rules.\n* readme tab: change_type values definition.\n\nThere are 4 actions possible:\n\n* change_response:\tChange the response to new.value\n* blank_response:\tRemove and NA the response\n* remove_survey:\tDelete the survey\n* no_action:\tNo action to take.\n\nThis log will have to be filled in with actions to take and new value if needed.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_xlsx_cleaning_log(my_combined_log,\n                         kobo_survey = my_kobo_survey,\n                         kobo_choices = my_kobo_choice,\n                         use_dropdown = T,\n                         sm_dropdown_type = \"logical\",\n                         output_path =  \"outputs/cleaning-log-with-kobo.xlsx\")\n```\n:::\n\n\nIf the KOBO information are provided and the **use_dropdown** argument is set to TRUE, **new_value** will have a data validation rule based on the KOBO options.\n\n::: {.callout-note}\nSelect multiple dummy columns (TRUE/FALSE or 1/0) are flagged and used later for the cleaning, not the parent column.\n:::\n\n# Exercises \n\nTry the following with a dataset:\n\n* Perform a check to spot personal identifiable information \n\n::: {.callout-note collapse=\"true\" appearance=\"minimal\"}\n### Expand to get a hint\nTry the function `check_pii`\n:::\n\n::: {.callout-tip collapse=\"true\" appearance=\"minimal\"}\n### Expand to get the answer\n```\nmy_raw_dataset %>% \n  check_pii(uuid_column = \"X_uuid\")\n```\n:::\n\n* Perform a check that will look at the percentages of missing value per observation and that will spot any observation that is *different*.\n\n::: {.callout-note collapse=\"true\" appearance=\"minimal\"}\n### Expand to get a hint\nTry the function `check_percentage_missing`\n:::\n\n::: {.callout-note collapse=\"true\" appearance=\"minimal\"}\n### Expand to get a hint\nDid you try to add a new column with `add_percentage_missing`\n:::\n\n::: {.callout-tip collapse=\"true\" appearance=\"minimal\"}\n### Expand to get the answer\n```\nmy_raw_dataset <- my_raw_dataset %>% \n  add_percentage_missing(kobo_survey = my_kobo_survey)\n  \nmy_raw_dataset %>% \n  check_percentage_missing(uuid_column = \"X_uuid\")\n```\n\nOr if using a log already\n\n```\nmore_logs$checked_dataset <- more_logs$checked_dataset %>% \n  add_percentage_missing(kobo_survey = my_kobo_survey)\nmore_logs %>% \n  check_percentage_missing(uuid_column = \"X_uuid\")\n```\n:::\n\n* create a logical check list with the following:\n  * household number (variable: *num_hh_member*) is above 8.\n  * the water source for drinking water is bottled (variable: *water_source_drinking*, value: *bottled*) and the household always treat the drinking water (variable: *treat_drink_water*, value: *always_treat*).\n  * the water source for drinking water is bottled (variable: *water_source_drinking*, value: *bottled*) and one of the main reason for the the household to not meet its water needs is the water pressure (variable: *access_water_enough_why_not*, value: *water_pressure*, this is a select multiple)\n\n::: {.callout-tip collapse=\"true\" appearance=\"minimal\"}\n### Expand to get the answer\n```\nmy_check_list <- data.frame(check_id = c(\"check_household number\", \"check_water_treatment\", \"check_3\"),\n                            description = c(\"num_hh_member is big\",\"using bottled water and always treat\",\"using bottled water and main reason is water pressure\"),\n                            check_to_perform = c(\"num_hh_member > 8\",\"water_source_drinking == \\\"bottled\\\" & treat_drink_water == \\\"always_treat\\\"\",\"water_source_drinking == \\\"bottled\\\" & access_water_enough_why_not.water_pressure == TRUE\"),\n                            columns_to_clean = c(\"num_hh_member\",\"water_source_drinking, treat_drink_water\",\"water_source_drinking, access_water_enough_why_not.water_pressure\"))\n\nmy_raw_dataset %>% \n    check_logical_with_list(uuid_column = \"X_uuid\",\n                          list_of_check = my_check_list,\n                          check_id_column = \"check_id\",\n                          check_to_perform_column = \"check_to_perform\",\n                          columns_to_clean_column = \"columns_to_clean\",\n                          description_column = \"description\")\n```\n:::\n\n* try add_duration on your dataset\nThere is no specific answer just now.\n\n::: {.callout-note collapse=\"true\" appearance=\"minimal\"}\n### Expand to get a tip\n```\nmy_raw_dataset$new_start <- ymd_hms(my_raw_dataset[[\"start\"]])\nmy_raw_dataset$new_end <- ymd_hms(my_raw_dataset[[\"end\"]])\nmy_raw_dataset$duration <- difftime(as.POSIXct(my_raw_dataset$new_start), as.POSIXct(my_raw_dataset$new_end), units = \"mins\")\n```\n:::\n\n\n# Creating a clean dataset\n\n::: {.callout-important}\nThe cleaning has to be filled before moving forward. The above steps are to create the cleaning log, not to **fill** it or **clean** the dataset. Filling the cleaning log is not an automatic step for this process. The decision to change a value has to be recorded.\n:::\n\n::: {.callout-tip appearance=\"minimal\"}\n### review_*\n\n**review_*** functions will review an object by comparing it to standards or another object and flags differences, e.g. analysis comparing it with another analysis. **check_*** functions will flag value in a dataset and return a log with those value. It only works on a **dataset** for the cleaning. **review_*** function are used for other steps:\n\n* if the cleaning has been filled correctly\n* the cleaning has been done correctly\n* comparing indicators\n* comparing analysis\n* etc.\n:::\n\n## review_cleaning_log\n\n`review_cleaning_log` will review the **filled** cleaning log. \n\n::: {.cell}\n\n```{.r .cell-code}\nmy_filled_log <- readxl::read_excel(\"outputs/cleaning-log-with-kobo - filled.xlsx\", sheet = 2)\n\ncheck_log_results <- review_cleaning_log(raw_dataset = my_raw_dataset,\n                                        raw_data_uuid_column = \"X_uuid\",\n                                        cleaning_log = my_filled_log, \n                                        cleaning_log_uuid_column = \"uuid\",\n                                        cleaning_log_question_column = \"question\",\n                                        cleaning_log_new_value_column = \"new_value\",\n                                        cleaning_log_change_type_column = \"change_type\",\n                                        change_response_value = \"change_response\")\ncheck_log_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"no issues in cleaning log found\"\n```\n:::\n:::\n\n## create_cleaning_data\nTo create the clean dataset, `create_clean_data` will use the raw dataset and the filled cleaning log.\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_clean_data <- create_clean_data(raw_dataset = my_raw_dataset,\n                                   raw_data_uuid_column = \"X_uuid\",\n                                   cleaning_log = my_filled_log, \n                                   cleaning_log_uuid_column = \"uuid\",\n                                   cleaning_log_question_column = \"question\",\n                                   cleaning_log_new_value_column = \"new_value\",\n                                   cleaning_log_change_type_column = \"change_type\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"water_supply_other_neighbourhoods_why\"\n[1] \"trust_water_office_why_not\"\n[1] \"pay_water_charges_amount\"\n[1] \"connection_fees_amount\"\n[1] \"connection_fees_amount\"\n[1] \"primary_livelihood.employment\"\n[1] \"primary_livelihood.employment\"\n[1] \"primary_livelihood.employment\"\n[1] \"tank_emptied\"\n[1] \"access_water_enough\"\n```\n:::\n:::\n\n## recreate_parent_column\n\nIn the cleaning log, some select multiple are changed, but only the dummy. The parent column should be recoded also.\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_filled_log %>% \n  filter(question == \"primary_livelihood.employment\", \n         change_type == \"change_response\") %>% \n  select(uuid, question, old_value, new_value)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |question                      |old_value |new_value |\n|:------------------------------------|:-----------------------------|:---------|:---------|\n|eb3b9935-fa0b-4d54-8058-3b629f1421ad |primary_livelihood.employment |TRUE      |FALSE     |\n|eec1f630-15d5-475e-a344-32bba74b32ea |primary_livelihood.employment |TRUE      |FALSE     |\n|f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |primary_livelihood.employment |TRUE      |FALSE     |\n\n</div>\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_clean_data %>% \n  filter(X_uuid %in% c(\"eb3b9935-fa0b-4d54-8058-3b629f1421ad\", \"eec1f630-15d5-475e-a344-32bba74b32ea\", \"f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\")) %>% \n  select(X_uuid,primary_livelihood, primary_livelihood.employment)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|X_uuid                               |primary_livelihood |primary_livelihood.employment |\n|:------------------------------------|:------------------|:-----------------------------|\n|f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |employment         |FALSE                         |\n|eb3b9935-fa0b-4d54-8058-3b629f1421ad |employment ngo     |FALSE                         |\n|eec1f630-15d5-475e-a344-32bba74b32ea |employment         |FALSE                         |\n\n</div>\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_clean_data2 <- recreate_parent_column(dataset = my_clean_data,\n                                         uuid_column = \"X_uuid\",\n                                         kobo_survey = my_kobo_survey,\n                                         kobo_choices = my_kobo_choice,\n                                         sm_separator = \".\", \n                                         cleaning_log_to_append = my_filled_log)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_clean_data2$data_with_fix_concat %>% \n  filter(X_uuid %in% c(\"eb3b9935-fa0b-4d54-8058-3b629f1421ad\", \"eec1f630-15d5-475e-a344-32bba74b32ea\", \"f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\")) %>% \n  select(X_uuid,primary_livelihood, primary_livelihood.employment)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|X_uuid                               |primary_livelihood |primary_livelihood.employment |\n|:------------------------------------|:------------------|:-----------------------------|\n|f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |NA                 |FALSE                         |\n|eb3b9935-fa0b-4d54-8058-3b629f1421ad |ngo                |FALSE                         |\n|eec1f630-15d5-475e-a344-32bba74b32ea |NA                 |FALSE                         |\n\n</div>\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_clean_data2$cleaning_log %>% \n  filter(question == \"primary_livelihood\", \n         uuid %in% c(\"eb3b9935-fa0b-4d54-8058-3b629f1421ad\", \"eec1f630-15d5-475e-a344-32bba74b32ea\", \"f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\")) %>% \n  select(uuid, question, old_value, new_value)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |question           |old_value      |new_value |\n|:------------------------------------|:------------------|:--------------|:---------|\n|eb3b9935-fa0b-4d54-8058-3b629f1421ad |primary_livelihood |employment ngo |ngo       |\n|eec1f630-15d5-475e-a344-32bba74b32ea |primary_livelihood |employment     |NA        |\n|f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |primary_livelihood |employment     |NA        |\n\n</div>\n:::\n:::\n\n\n## review_others\n\nIn the cleaning log, some opentext values are changed to blank. Some open text questions are linked some skip logic, i.e. *what is X? Other, please specify*. In some cases, values some values should be changed. \n\nIn the example below, the value for **water_supply_other_neighbourhoods_why** for the **uuid 019bc718-c06a-46b8-bba8-c84f6c6efbd5** was changed to NA.\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_filled_log %>% \n  filter(question == \"water_supply_other_neighbourhoods_why\", \n         change_type == \"blank_response\")\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |old_value |question                              |issue        |check_id |check_binding                                                                  |change_type    |new_value | enumerator_num|\n|:------------------------------------|:---------|:-------------------------------------|:------------|:--------|:------------------------------------------------------------------------------|:--------------|:---------|--------------:|\n|019bc718-c06a-46b8-bba8-c84f6c6efbd5 |لا اعلم   |water_supply_other_neighbourhoods_why |recode other |NA       |water_supply_other_neighbourhoods_why ~/~ 019bc718-c06a-46b8-bba8-c84f6c6efbd5 |blank_response |NA        |             12|\n\n</div>\n:::\n:::\n\nThe kobo show a skip logic based on **water_supply_other_neighbourhoods**.\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_kobo_survey %>% \n  filter(name == \"water_supply_other_neighbourhoods_why\") %>% \n  select(type, name, relevant)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|type |name                                  |relevant                                                                                                                       |\n|:----|:-------------------------------------|:------------------------------------------------------------------------------------------------------------------------------|\n|text |water_supply_other_neighbourhoods_why |selected(${water_supply_other_neighbourhoods},'somewhat_worse') or selected(${water_supply_other_neighbourhoods},'much_worse') |\n\n</div>\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_clean_data %>% \n  filter(X_uuid == \"019bc718-c06a-46b8-bba8-c84f6c6efbd5\") %>% \n  select(water_supply_other_neighbourhoods, water_supply_other_neighbourhoods_why\t)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|water_supply_other_neighbourhoods |water_supply_other_neighbourhoods_why |\n|:---------------------------------|:-------------------------------------|\n|somewhat_worse                    |NA                                    |\n\n</div>\n:::\n:::\n\nShould the value of **water_supply_other_neighbourhoods** be changed? It depends on the question and skip logic but it important to flag those so a decision can be taken.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreview_other_log <- review_others(dataset = my_clean_data2$data_with_fix_concat,\n                                  uuid_column = \"X_uuid\", \n                                  kobo_survey = my_kobo_survey, \n                                  columns_not_to_check = \"consent_telephone_number\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in create_logic_for_other(kobo_survey = kobo_survey,\ncompare_with_dataset = TRUE, : The following parent names: well_quality,\nspring_quality, rainwater_quality, surface_quality, why_not_connected were not\nfound in the dataset. The function is ignoring them.\n```\n:::\n:::\n\n\n## review_cleaning\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_deletion_log <- my_clean_data2$cleaning_log %>% \n  dplyr::filter(change_type == \"remove_survey\")\n\nmy_filled_log_no_deletion <- my_clean_data2$cleaning_log %>% \n  dplyr::filter(change_type != \"remove_survey\") %>% \n  dplyr::filter(!uuid %in% my_deletion_log$uuid)\n\nreview_of_cleaning <- review_cleaning(raw_dataset = my_raw_dataset,\n                    raw_dataset_uuid_column = \"X_uuid\", \n                    clean_dataset = my_clean_data2$data_with_fix_concat,\n                    clean_dataset_uuid_column = \"X_uuid\",\n                    cleaning_log = my_filled_log_no_deletion, \n                    cleaning_log_uuid_column = \"uuid\",\n                    cleaning_log_question_column = \"question\",\n                    cleaning_log_new_value_column = \"new_value\",\n                    cleaning_log_change_type_column = \"change_type\", \n                    cleaning_log_old_value_column = \"old_value\", \n                    deletion_log = my_deletion_log, \n                    deletion_log_uuid_column = \"uuid\"\n                    )\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}