{
  "hash": "ac56b63518f5039e67a6e29f6c648a47",
  "result": {
    "markdown": "---\ntitle: \"R cozy winter\"\nauthor: \"Yann Say\"\ndate: today\n\nformat:\n  html:\n    toc: true\n    css: css/styles.css\n    df-print: kable\n    embed-resources: true\n\n---\n\n# IMPACT R framework\n\n---\n\nThe IMPACT R framework has been developed to meet the requirements of the IMPACT research cycle. \n<br/><br/> \nThe ecosystem is a modular framework with two dimensions:\n\n-   a horizontal dimension that focuses on the outcome of a given step, and\n-   a vertical dimension that focuses on the content of a given step.\n\n---\n\nThe framework is built around:\n\n-   4 ~~packages~~ steps: cleaning, ~~indicators~~ composition, analysis, outputs\n-   4 verbs: check, add, create, review\n-   2 adjectives: pipeable, independent\n\nThese elements will help to improve cooperation and collaboration between different teams while \nallowing modularity to adapt to each context and assessment.\n\n---\n\n![](images/rframwork.png)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cleaningtools)\nlibrary(dplyr)\n\nmy_raw_dataset <- cleaningtools::cleaningtools_raw_data\nmy_kobo_survey <- cleaningtools::cleaningtools_survey\nmy_kobo_choice <- cleaningtools::cleaningtools_choices\n```\n:::\n\n# Checking a dataset\n\n## check_*\n\nThe framework is built around 4 verbs: **add**, **check**, **create**, **review**. Most of the functions to check the cleaning will be around the verb **check**. A **check_*** function will flag values based on a specific check. It will return them in a log. A **check_*** will returns a list: the checked dataset, and the log. \n**check_*** functions are used only in the cleaning step.\n\n### check_outliers\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log1 <- my_raw_dataset %>% \n  check_outliers(uuid_column = \"X_uuid\")\n```\n:::\n\n\nIn this example, there are:\n\n* `checked_dataset`: the raw dataset (with extra variables if needed)\n* `potential_outliers`: a log of potential outliers\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(my_log1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nmy_log1 %>% \n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"checked_dataset\"    \"potential_outliers\"\n```\n:::\n:::\n\n\nThe log has at least 4 columns:\n\n* `uuid`: the unique identifier\n* `issue`: the issue being flagged\n* `question`: the name of the question\n* `old_value`: the value being flagged\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log1$potential_outliers %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |issue                         |question         | old_value|\n|:------------------------------------|:-----------------------------|:----------------|---------:|\n|b5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06 |outlier (normal distribution) |age_respondent_r |        86|\n|956b5ed0-5a62-41b7-aec3-af93fbc5b494 |outlier (normal distribution) |age_respondent_r |        84|\n|97ad6294-30c6-454e-a0b3-42126415b767 |outlier (log distribution)    |age_respondent_r |        18|\n|e005e719-57c4-44a3-ac2f-5d6d1ff68831 |outlier (log distribution)    |age_respondent_r |        18|\n|c9aaa542-118f-4e42-93de-fb0916572541 |outlier (normal distribution) |num_hh_member    |        19|\n|48e8896b-d1be-4600-8839-2d8b994ebcfb |outlier (normal distribution) |num_hh_member    |        19|\n\n</div>\n:::\n:::\n\n\n::: {.callout-note .column-margin}\nOutliers are defined as +/- 3 standard deviation from the mean. \n\nFor log outliers, log(x + 1) is used.\n:::\n\n### check_duplicate\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log2 <- my_raw_dataset %>% \n  check_duplicate(uuid_column = \"X_uuid\")\n\nmy_log2$duplicate_log %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid |old_value |question |issue |\n|:----|:---------|:--------|:-----|\n\n</div>\n:::\n:::\n\n\nThere is no duplicate. The log is empty.\n\n## Pipe-able\nThe framework is built around 2 adjectives, **pipe-able** and **independent**. In the framework, functions of the same family should be pipe-able. In the following case, 2 **check_*** functions are piped.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log3 <- my_raw_dataset %>% \n  check_outliers(uuid_column = \"X_uuid\") %>% \n  check_duplicate(uuid_column = \"X_uuid\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(my_log3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"checked_dataset\"    \"potential_outliers\" \"duplicate_log\"     \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log3$potential_outliers %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |issue                         |question         | old_value|\n|:------------------------------------|:-----------------------------|:----------------|---------:|\n|b5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06 |outlier (normal distribution) |age_respondent_r |        86|\n|956b5ed0-5a62-41b7-aec3-af93fbc5b494 |outlier (normal distribution) |age_respondent_r |        84|\n|97ad6294-30c6-454e-a0b3-42126415b767 |outlier (log distribution)    |age_respondent_r |        18|\n|e005e719-57c4-44a3-ac2f-5d6d1ff68831 |outlier (log distribution)    |age_respondent_r |        18|\n|c9aaa542-118f-4e42-93de-fb0916572541 |outlier (normal distribution) |num_hh_member    |        19|\n|48e8896b-d1be-4600-8839-2d8b994ebcfb |outlier (normal distribution) |num_hh_member    |        19|\n\n</div>\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_log3$duplicate_log %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid |old_value |question |issue |\n|:----|:---------|:--------|:-----|\n\n</div>\n:::\n:::\n\n\nThis an example of more checks that exist.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmore_logs <- my_raw_dataset %>% \n  check_duplicate(uuid_column = \"X_uuid\") %>% \n  check_soft_duplicates(uuid_column = \"X_uuid\", kobo_survey = my_kobo_survey, sm_separator = \".\") %>%\n  check_outliers(uuid_column = \"X_uuid\") %>%\n  check_value(uuid_column = \"X_uuid\") \n```\n:::\n\n\n## add_* \n\n**add_*** functions will add a variable (column) to the dataset. For example, to check the duration of a survey, there is only the start and end, but not the duration column. \n\n### add_duration\n\n::: {.cell}\n\n```{.r .cell-code}\nmore_logs$checked_dataset <- more_logs$checked_dataset %>% \n  add_duration(uuid_column = \"X_uuid\", start_column = \"X.U.FEFF.start\", end_column = \"end\")\nmore_logs$checked_dataset[1:6, c(\"start_date\", \"start_time\", \"end_date\", \"end_time\", \"days_diff\", \"duration\")]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|start_date |start_time   |end_date   |end_time     |days_diff | duration|\n|:----------|:------------|:----------|:------------|:---------|--------:|\n|2021-07-05 |658.57 mins  |2021-07-05 |696.68 mins  |0 days    |    38.11|\n|2021-07-05 |608.90 mins  |2021-07-05 |641.92 mins  |0 days    |    33.02|\n|2021-07-05 |682.23 mins  |2021-07-05 |726.43 mins  |0 days    |    44.20|\n|2021-07-04 |1342.98 mins |2021-07-04 |1380.15 mins |0 days    |    37.17|\n|2021-07-04 |1391.62 mins |2021-07-05 |18.88 mins   |1 days    |    67.26|\n|2021-07-05 |617.38 mins  |2021-07-05 |756.52 mins  |0 days    |   139.14|\n\n</div>\n:::\n:::\n\n::: {.callout-warning .column-margin}\nThe duration is added to the `checked_dataset` in the list, not in the `my_raw_dataset` dataframe. The **check_*** functions are used in a pipe, so it needs the current dataset to be modified.\n:::\n\n::: {.callout-warning .column-margin}\nAt the moment, `add_duration` takes very specific format. It will change in the future to become more robust and using **lubridate**.\n:::\n\n`check_duration` can now be used with the previous checks.\n\n::: {.cell}\n\n```{.r .cell-code}\nmore_logs <- more_logs %>% \n  check_duration(column_to_check = \"duration\", uuid_column = \"X_uuid\")\n```\n:::\n\n\n## check_* and arguments\n\nAs much as possible, **check_*** functions take default argument or the functions will be able to guess some information, e.g. the `check_outliers` function guesses some numerical values. Some functions need more information.\n\n### other/text columns\n`check_other` needs the list of columns to be checked. It currently, it cannot detect the open text question. KOBO tool can be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nother_columns_to_check <- my_kobo_survey %>% \n  dplyr::filter(type == \"text\") %>% \n  dplyr::filter(name %in% names(my_raw_dataset)) %>%\n  dplyr::pull(name) \n\nmore_logs <- more_logs %>% \n  check_others(uuid_column = \"X_uuid\", columns_to_check = other_columns_to_check) \n```\n:::\n\n\n### check_logical\nIn other cases, the check is specific and should be tailored to the dataset, for example, `check_logical`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_logic <- my_raw_dataset %>% \n  check_logical(uuid_column = \"X_uuid\", \n                check_to_perform = \"primary_livelihood.employment == 1 & tot_expenses < 200000\",\n                description = \"primary_livelihood is employment but expenses less than 200 000\",\n                columns_to_clean = c(\"primary_livelihood\", \"tot_expenses\"))\n\nexample_logic$logical_xx %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |question           |old_value  |issue                                                           |check_id   |check_binding                                       |\n|:------------------------------------|:------------------|:----------|:---------------------------------------------------------------|:----------|:---------------------------------------------------|\n|f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |primary_livelihood |employment |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |\n|f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |tot_expenses       |125000     |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb |\n|e9f8b44c-c507-45a1-8d76-66d886437b8f |primary_livelihood |employment |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ e9f8b44c-c507-45a1-8d76-66d886437b8f |\n|e9f8b44c-c507-45a1-8d76-66d886437b8f |tot_expenses       |175000     |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ e9f8b44c-c507-45a1-8d76-66d886437b8f |\n|994a60b8-e640-425c-9774-160651d7af04 |primary_livelihood |employment |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ 994a60b8-e640-425c-9774-160651d7af04 |\n|994a60b8-e640-425c-9774-160651d7af04 |tot_expenses       |175000     |primary_livelihood is employment but expenses less than 200 000 |logical_xx |logical_xx ~/~ 994a60b8-e640-425c-9774-160651d7af04 |\n\n</div>\n:::\n:::\n\nThe log returns :\n\n* uuid\n* question: for all variables in **columns_to_clean**\n* old value: for all variables in **columns_to_clean**\n* issue\n* check_id: logical check identifier\n* check_binding: the combination of the check_id and the uuid. \n\nOne check can be flagged in several rows, in the example above, for each uuid, the primary_livelihood and tot_expenses are flagged.\n\nFormat for the **test_to_perform** should take the format based on *tidyverse*. That format is as if a new indicator is create with a `mutate`. That new indicator should be a logical (i.e. TRUE or FALSE) with TRUE being the value to flag. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_raw_dataset %>% \n  dplyr::mutate(xxx =  primary_livelihood == \"employment\" & tot_expenses < 1000000) %>% \n  dplyr::select(X_uuid, xxx, primary_livelihood, tot_expenses) %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|X_uuid                               |xxx   |primary_livelihood | tot_expenses|\n|:------------------------------------|:-----|:------------------|------------:|\n|dcf2753a-6ea2-40f5-b493-3527931ef96c |FALSE |loans support      |       250000|\n|8790ce5c-1c35-41a2-b3c0-538f937d5397 |TRUE  |employment         |       750000|\n|bb818e04-9c40-408e-919f-6b40ff1fdbb3 |FALSE |other              |       250000|\n|28b90cbb-2cf0-41c5-9ee1-1c719c0d4c02 |TRUE  |employment         |       600000|\n|7f2a0c6a-529b-481f-963f-a96dca2ec034 |TRUE  |employment         |       500000|\n|b4f92064-12ea-4970-b0f5-fd309de1dda3 |FALSE |retirement_fund    |       650000|\n\n</div>\n:::\n:::\n\n\nThe checked dataset will be return with one extra column, i.e. the logical variable with the name of the **check_id**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_logic$checked_dataset[1:6,tail(names(example_logic$checked_dataset))]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|X_submission_time   |X_notes |X_status          |X_submitted_by | X_index|logical_xx |\n|:-------------------|:-------|:-----------------|:--------------|-------:|:----------|\n|2021-07-05T09:34:15 |[]      |submitted_via_web |reach_irq      |       1|FALSE      |\n|2021-07-05T09:34:09 |[]      |submitted_via_web |reach_irq      |       2|FALSE      |\n|2021-07-05T09:34:33 |[]      |submitted_via_web |reach_irq      |       3|FALSE      |\n|2021-07-05T09:32:58 |[]      |submitted_via_web |reach_irq      |       4|FALSE      |\n|2021-07-05T09:32:59 |[]      |submitted_via_web |reach_irq      |       5|FALSE      |\n|2021-07-05T09:37:33 |[]      |submitted_via_web |reach_irq      |       6|FALSE      |\n\n</div>\n:::\n:::\n\n\n**check_to_perform** is written as a character, between quotes and using with regular expression, e.g. escaping the quotes in **\"employment\"**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_logic2 <- my_raw_dataset %>% \n  check_logical(uuid_column = \"X_uuid\", \n                check_to_perform = \"primary_livelihood == \\\"employment\\\" & tot_expenses < 1000000\",\n                description = \"primary_livelihood is rented but expenses less than 1 000 000\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in check_logical(., uuid_column = \"X_uuid\", check_to_perform\n= \"primary_livelihood == \\\"employment\\\" & tot_expenses < 1000000\", :\ncolumns_to_clean not shared, results may not be accurate\n```\n:::\n\n```{.r .cell-code}\nexample_logic2$logical_xx %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |question           |old_value  |issue                                                         |check_id   |check_binding                                       |\n|:------------------------------------|:------------------|:----------|:-------------------------------------------------------------|:----------|:---------------------------------------------------|\n|8790ce5c-1c35-41a2-b3c0-538f937d5397 |primary_livelihood |employment |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 8790ce5c-1c35-41a2-b3c0-538f937d5397 |\n|8790ce5c-1c35-41a2-b3c0-538f937d5397 |tot_expenses       |750000     |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 8790ce5c-1c35-41a2-b3c0-538f937d5397 |\n|28b90cbb-2cf0-41c5-9ee1-1c719c0d4c02 |primary_livelihood |employment |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 28b90cbb-2cf0-41c5-9ee1-1c719c0d4c02 |\n|28b90cbb-2cf0-41c5-9ee1-1c719c0d4c02 |tot_expenses       |600000     |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 28b90cbb-2cf0-41c5-9ee1-1c719c0d4c02 |\n|7f2a0c6a-529b-481f-963f-a96dca2ec034 |primary_livelihood |employment |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 7f2a0c6a-529b-481f-963f-a96dca2ec034 |\n|7f2a0c6a-529b-481f-963f-a96dca2ec034 |tot_expenses       |500000     |primary_livelihood is rented but expenses less than 1 000 000 |logical_xx |logical_xx ~/~ 7f2a0c6a-529b-481f-963f-a96dca2ec034 |\n\n</div>\n:::\n:::\n\n\n::: {.callout-note .column-margin}\nIf you don't include **columns_to_clean** the `check_logical` function will try to guess the variables. Not guarantee it will read or pick the correct names.\n:::\n\nThis inherits from reading a checklist in an Excel format. In Excel, there is no quote.\n\n![](images/excelchecklist.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical_check_list <- readxl::read_excel(\"inputs/check_list.xlsx\")\nlogical_check_list\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|check_id |description                                                    |check_to_perform                                                             |columns_to_clean                                     |\n|:--------|:--------------------------------------------------------------|:----------------------------------------------------------------------------|:----------------------------------------------------|\n|check_1  |primary_livelihood is employment but expenses less than 200000 |primary_livelihood.employment == 1 & tot_expenses < 200000                   |primary_livelihood.employment,          \ntot_expenses |\n|check_2  |acces water and tank emptied                                   |access_water_enough == \"totally_insufficient\" & tank_emptied == \"about_half\" |access_water_enough, tank_emptied                    |\n\n</div>\n:::\n:::\n\nThis list can then be used with `check_logical_with_list`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmore_logs <- more_logs %>% \n  check_logical_with_list(uuid_column = \"X_uuid\",\n                          list_of_check = logical_check_list,\n                          check_id_column = \"check_id\",\n                          check_to_perform_column = \"check_to_perform\",\n                          columns_to_clean_column = \"columns_to_clean\",\n                          description_column = \"description\")\n```\n:::\n\n\n# Creating a cleaning log\n\n## create_*\n\n**create_*** functions will create, transform something, for example, creating a cleaning log to be filled from the checks that were performed above. **create_*** outputs can be in different shape, format, etc. **create_*** function is catch-all. \n\n### create_combined_log\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(more_logs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"checked_dataset\"    \"duplicate_log\"      \"soft_duplicate_log\"\n[4] \"potential_outliers\" \"flaged_value\"       \"duration_log\"      \n[7] \"other_log\"          \"logical_all\"       \n```\n:::\n\n```{.r .cell-code}\nmy_combined_log <- create_combined_log(more_logs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of element to combine- checked_dataset, duplicate_log, soft_duplicate_log, potential_outliers, flaged_value, duration_log, other_log, logical_all\n```\n:::\n\n```{.r .cell-code}\ntypeof(my_combined_log)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nnames(my_combined_log)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"checked_dataset\" \"cleaning_log\"   \n```\n:::\n\n```{.r .cell-code}\nmy_combined_log$cleaning_log %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |old_value |question         |issue                         |check_id |check_binding                                             |change_type |new_value |\n|:------------------------------------|:---------|:----------------|:-----------------------------|:--------|:---------------------------------------------------------|:-----------|:---------|\n|b5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06 |86        |age_respondent_r |outlier (normal distribution) |NA       |age_respondent_r ~/~ b5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06 |NA          |NA        |\n|956b5ed0-5a62-41b7-aec3-af93fbc5b494 |84        |age_respondent_r |outlier (normal distribution) |NA       |age_respondent_r ~/~ 956b5ed0-5a62-41b7-aec3-af93fbc5b494 |NA          |NA        |\n|97ad6294-30c6-454e-a0b3-42126415b767 |18        |age_respondent_r |outlier (log distribution)    |NA       |age_respondent_r ~/~ 97ad6294-30c6-454e-a0b3-42126415b767 |NA          |NA        |\n|e005e719-57c4-44a3-ac2f-5d6d1ff68831 |18        |age_respondent_r |outlier (log distribution)    |NA       |age_respondent_r ~/~ e005e719-57c4-44a3-ac2f-5d6d1ff68831 |NA          |NA        |\n|c9aaa542-118f-4e42-93de-fb0916572541 |19        |num_hh_member    |outlier (normal distribution) |NA       |num_hh_member ~/~ c9aaa542-118f-4e42-93de-fb0916572541    |NA          |NA        |\n|48e8896b-d1be-4600-8839-2d8b994ebcfb |19        |num_hh_member    |outlier (normal distribution) |NA       |num_hh_member ~/~ 48e8896b-d1be-4600-8839-2d8b994ebcfb    |NA          |NA        |\n\n</div>\n:::\n:::\n\nThe cleaning log contains all the columns from all the logs from `more_logs` with in addition:\n\n* check_binding is filled for all rows.\n* change_type (empty)\n* new_value (empty)\n\n### add_info_to_cleaning_log\n\nIf more information from the dataset should be added, the function `add_info_to_cleaning_log` can help.\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_combined_log <- my_combined_log %>% \n  add_info_to_cleaning_log(dataset_uuid_column = \"X_uuid\", \n                           information_to_add = \"enumerator_num\")\n\nmy_combined_log$cleaning_log %>% \n  head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|uuid                                 |old_value                                                                        |question                              |issue                                           |check_id |check_binding                                                                  |change_type |new_value | enumerator_num|\n|:------------------------------------|:--------------------------------------------------------------------------------|:-------------------------------------|:-----------------------------------------------|:--------|:------------------------------------------------------------------------------|:-----------|:---------|--------------:|\n|019bc718-c06a-46b8-bba8-c84f6c6efbd5 |لا اعلم                                                                          |water_supply_other_neighbourhoods_why |recode other                                    |NA       |water_supply_other_neighbourhoods_why ~/~ 019bc718-c06a-46b8-bba8-c84f6c6efbd5 |NA          |NA        |             12|\n|019bc718-c06a-46b8-bba8-c84f6c6efbd5 |لا ارى جدوى من ذلك                                                               |prefer_not_engage_other               |recode other                                    |NA       |prefer_not_engage_other ~/~ 019bc718-c06a-46b8-bba8-c84f6c6efbd5               |NA          |NA        |             12|\n|019bc718-c06a-46b8-bba8-c84f6c6efbd5 |السلطات ليست مهتمة بالخدمات                                                      |trust_water_office_why_not            |recode other                                    |NA       |trust_water_office_why_not ~/~ 019bc718-c06a-46b8-bba8-c84f6c6efbd5            |NA          |NA        |             12|\n|019bc718-c06a-46b8-bba8-c84f6c6efbd5 |247.20                                                                           |duration                              |Duration is lower or higher than the thresholds |NA       |duration ~/~ 019bc718-c06a-46b8-bba8-c84f6c6efbd5                              |NA          |NA        |             12|\n|03183d24-0275-43fe-8976-d076f29de590 |عدم توفير خدمه المياه  في المنطقه وضعف في تزويد خدمه وعدد ساعات اقل تجهيز للبيوت |water_supply_other_neighbourhoods_why |recode other                                    |NA       |water_supply_other_neighbourhoods_why ~/~ 03183d24-0275-43fe-8976-d076f29de590 |NA          |NA        |              2|\n|03183d24-0275-43fe-8976-d076f29de590 |10                                                                               |pay_water_charges_amount              |outlier (log distribution)                      |NA       |pay_water_charges_amount ~/~ 03183d24-0275-43fe-8976-d076f29de590              |NA          |NA        |              2|\n\n</div>\n:::\n:::\n\n\n### create_xlsx_cleaning_log\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_xlsx_cleaning_log(my_combined_log,\n                         sm_dropdown_type = \"logical\",\n                         output_path =  \"outputs/cleaning-log-no-kobo.xlsx\")\n```\n:::\n\n\n`create_xlsx_cleaning_log` will write an excel file with:\n\n* checked_dataset tab: the checked dataset, with additional columns if any.\n* cleaning_log tab: the combined log with the **change_type** column with a data validation rules.\n* readme tab: change_type values definition.\n\nThere are 4 actions possible:\n\n* change_response:\tChange the response to new.value\n* blank_response:\tRemove and NA the response\n* remove_survey:\tDelete the survey\n* no_action:\tNo action to take.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_xlsx_cleaning_log(my_combined_log,\n                         kobo_survey = my_kobo_survey,\n                         kobo_choices = my_kobo_choice,\n                         use_dropdown = T,\n                         sm_dropdown_type = \"logical\",\n                         output_path =  \"outputs/cleaning-log-with-kobo.xlsx\")\n```\n:::\n\n\nIf the KOBO information are provided and the **use_dropdown** argument is set to TRUE, **new_value** will have a data validation rule based on the KOBO options.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}